goog.provide("mix.ui.Recipes");

goog.require("mix.domlib");
goog.require("mix.objlib");

goog.require("mix.lib.TemplateManager");
goog.require("mix.lib.OrderedArray");

goog.require("mix.ui.Ingredients");
goog.require("mix.ui.IngStatus");
goog.require("mix.ui.Settings");
goog.require("mix.ui.SortIncompleteBy");


/**
 * Creates a recipe list. This is a list of 10 categories. The categories
 * can be modified by the "type" setting. Each category contains a list of
 * dom elements - one per recipe. The recipe dom can be generated by an
 * external function. This object handles keeping the recipes sorted and in
 * their proper categories whenever ingredients change.
 * @class
 * @constructor
 * @param {Element} domContainer the parent dom element that this object controls.
 * @param {mix.lib.TemplateManager} templates the template library used for this 
 * @param {string} recipeTempId the ID of the template to use for each recipe card
 * @param {string} categoryHeaderTempId the ID of the template to use for the category headers
 * @param {string} categoryListTempId the ID of the template to use for category containers
 */
mix.ui.Recipes = function(domContainer, templates, recipeTempId, categoryHeaderTempId, categoryListTempId) {
    this.domContainer = domContainer;
    this.sortType = null;
    this.templates = templates;
    this.tidRecipe = recipeTempId;
    this.tidCatHeader = categoryHeaderTempId;
    this.tidCatList = categoryListTempId;
    var numContainers = 10;

    //titles (h2)
    this.catTitleDom = [];
    var cn = "";
    for(var i=0; i < numContainers; i+=1) {
        this.catTitleDom[i] = this.templates.generateDom(this.tidCatHeader, {
            "mainClass": i === 0 ? "catTitle" : "catTitle incomplete",
            "missing": i,
            "isNotOne": i !== 1 ? "" : "hidden",
            "isLast": i === numContainers-1 ? "" : "hidden",
            "percentHave": (i === numContainers - 1 ? "20" : (100-i*10))+"%"
        });
    }

    //content boxes (ol)
    //
    /** @type {Array.<Node>} */
    this.catContentDom = [];
    /** @type {Array.<mix.lib.OrderedArray>} */
    this.catContent = [];
    for(i=0; i < numContainers; i+=1) {
        this.catContent[i] = new mix.lib.OrderedArray();
        this.catContentDom[i] = this.templates.generateDom(this.tidCatList, {
            "mainClass": i === 0 ? "" : "incomplete"
        });
    }

    //recipes (li)
    /** @type {Object.<string, Node>} drink name to dom */
    this.drinkDomMap = {};
    /** @type {Object.<string, number>} drink name to category number */
    this.drinkCurCat = {};
    for(var drinkName in mixDataDrinks) {
        this.drinkDomMap[drinkName] = this.templates.generateDom(this.tidRecipe, mixDataDrinks[drinkName]);
    }

    //set content of h2 and ol
    var totalDom = Math.min(this.catTitleDom.length, this.catContentDom.length);
    for(i=0; i < totalDom; i+=1) {
        domContainer.appendChild(this.catTitleDom[i]);
        domContainer.appendChild(this.catContentDom[i]);
    }
};

/**
 * Updates the UI to reflect changes in a given ingredient list.
 * @param {mix.ui.Ingredients} ingList the list of ingredients to pull from
 * @param {mix.ui.Settings} settings the settings that control how the UI is organized
 * @param {mix.ui.SortIncompleteBy=} newSortType the method of sorting into categories
 * @this {mix.ui.Recipes}
 */
mix.ui.Recipes.prototype.changeIngredient = function changeIngredient(ingList, settings, newSortType) {
    var i = 0;
    var self = this;

    if (newSortType !== undefined && newSortType !== null) {
        if (!this.sortType) {this.sortType = 0;}
        this.domContainer.classList.remove("sortType"+this.sortType);
        this.sortType = newSortType;
        this.domContainer.classList.add("sortType"+this.sortType);
    }
    //re-arrange drinks
    var removeDrink = function(drinkName, domDrink) {
        var curIndex = self.drinkCurCat[drinkName];
        if (curIndex !== null && curIndex !== undefined) {
            self.catContent[curIndex].remove(drinkName);
        }
        if (domDrink.parentNode) {
            domDrink.parentNode.removeChild(domDrink);
        }
    };
    var addDrink = function(newCatIndex, drinkName, domDrink) {
        var orderIndex = self.catContent[newCatIndex].insert(drinkName);
        var drinkAfter = self.catContent[newCatIndex].data[orderIndex+1];
        if (drinkAfter === null || drinkAfter === undefined) {
            self.catContentDom[newCatIndex].appendChild(domDrink);
        } else {
            self.catContentDom[newCatIndex].insertBefore(domDrink,
                                            self.drinkDomMap[drinkAfter]);
        }
        self.drinkCurCat[drinkName] = newIndex;
    };

    for(var drinkName in mixDataDrinks) {
        var anyNeeded = ingList.numberNeeded() > 0;
        var st = mix.ui.IngStatus.NONE;
        var need = false;
        var have = 0;
        var drink = mixDataDrinks[drinkName];
        var domDrink = this.drinkDomMap[drinkName];
        var domPar = domDrink.parentNode;
        var total = drink["ingredients"].length;

        if (ingList) {
            for(i=0; i < total; i+=1) {
                var ing = drink["ingredients"][i].id;
                st = ingList.getIngredientStatus(ing);
                need = need || st === mix.ui.IngStatus.NEED;
                have += st === mix.ui.IngStatus.HAVE ||
                        st === mix.ui.IngStatus.NEED ? 1 : 0;
            }
        }
        
        if ((anyNeeded && need) || !anyNeeded) { //add to a cat
            var newIndex = 0;
            if (!this.sortType || this.sortType === mix.ui.SortIncompleteBy.NUMBER_NEEDED) {
                newIndex = total - have;
            } else { //PERCENT_LEFT
                newIndex = 10 - parseInt(have/total * 10, 10);
            }
            newIndex = Math.min(Math.max(0, newIndex), this.catContentDom.length-1);

            if (domPar !== this.catContentDom[newIndex]) {
                removeDrink(drinkName, domDrink);
                addDrink(newIndex, drinkName, domDrink);
            }

        } else { //this node shouldn't be in a cat
            removeDrink(drinkName, domDrink);
        }
    }

    //make sure visible categories / h2s are visible and others are not
    for(i=0; i < this.catContentDom.length; i+=1) {
        if (mix.objlib.trim(this.catContentDom[i].innerHTML) === "") {
            this.catTitleDom[i].style.display = "none";
        } else {
            this.catTitleDom[i].style.display = "";
        }
    }
};
